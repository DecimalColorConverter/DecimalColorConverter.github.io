<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>헬로펫 픽셀아트 에디터</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mdbassit/Coloris@latest/dist/coloris.min.css"/>
  <script src="https://cdn.jsdelivr.net/gh/mdbassit/Coloris@latest/dist/coloris.min.js"></script>

  <style>
    :root {
      --grid-cols: 16;
      --grid-rows: 16;
      --pixel-size: 25px;
      --default-pixel-size: 25px;
      --mobile-pixel-size: 20px;
      
      --accent-color: #275efe;
      --text-color: #333;
      --bg-color: #f4f7fa;
      --tool-bg: #ffffff;
      --border-color: #e0e5ec;
      --grid-line-color: #ddd;
      --shadow-color: rgba(0, 0, 0, 0.05);
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    @import url('https://cdn.jsdelivr.net/npm/pretendard/dist/web/static/pretendard.css'); 

    body {
        font-family: 'Pretendard', sans-serif; 
        padding: 15px;
        background-color: var(--bg-color);
        color: var(--text-color);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        transition: background-color 0.3s, color 0.3s;
    }
    
    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      width: 100%;
      max-width: 1000px;
      margin: 0 auto;
      flex: 1;
    }
    
    h1 {
      font-size: 28px;
      color: var(--text-color);
      cursor: pointer;
      user-select: none;
      font-weight: 700;
    }
    
    .tools {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      width: 100%;
      padding: 10px;
      border-radius: 12px;
      background: var(--tool-bg);
      border: 1px solid var(--border-color);
      box-shadow: 0 4px 12px var(--shadow-color);
      transition: background-color 0.3s, border-color 0.3s;
    }
    
    .tool-group {
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 5px;
      border-right: 1px solid var(--border-color);
    }
    .tool-group:last-child {
        border-right: none;
    }
    
    .tool-button {
      width: 40px;
      height: 40px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background: var(--tool-bg);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease-out;
      color: var(--text-color);
    }
    
    .tool-button:hover {
      background-color: #f0f3f6;
      transform: translateY(-2px);
    }
    
    .tool-button:active, .tool-button.active {
      background-color: var(--accent-color);
      color: white;
      border-color: var(--accent-color);
      transform: translateY(1px);
    }

    .tool-button svg {
      width: 20px;
      height: 20px;
    }
    
    .color-picker {
      display: flex;
      align-items: center;
    }
    
    #color-input {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid var(--border-color);
      transition: border-color 0.2s;
      padding: 0;
      text-indent: 40px;
      overflow: hidden;
    }
    #color-input:hover {
      border-color: var(--accent-color);
    }
    
    #color-hex {
      width: 65px;
      height: 32px;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 4px 6px;
      font-size: 12px;
      margin-left: 8px;
      text-align: center;
      transition: background-color 0.3s, color 0.3s, border-color 0.3s;
    }
    
    .canvas-size {
      display: flex;
      gap: 6px;
      align-items: center;
    }
    
    .canvas-size input {
      width: 40px;
      height: 32px;
      text-align: center;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      font-family: 'Pretendard', sans-serif;
      font-size: 14px;
      color: var(--text-color);
      background-color: #fff;
      transition: background-color 0.3s, color 0.3s, border-color 0.3s;
    }
    
    .canvas-container {
      width: 100%;
      overflow: auto;
      background-color: var(--tool-bg);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 10px;
      display: flex;
      justify-content: center;
      align-items: center;
      box-shadow: 0 4px 12px var(--shadow-color);
    }

    .pixel-grid {
      display: grid;
      grid-template-columns: repeat(var(--grid-cols), var(--pixel-size));
      grid-template-rows: repeat(var(--grid-rows), var(--pixel-size));
      user-select: none;
      -webkit-user-select: none;
      border: 1px solid var(--grid-line-color);
      border-right: none;
      border-bottom: none;
    }
    
    .pixel {
      width: var(--pixel-size);
      height: var(--pixel-size);
      background-color: #ffffff;
      cursor: pointer;
      border-right: 1px solid var(--grid-line-color);
      border-bottom: 1px solid var(--grid-line-color);
      transition: border-color 0.3s;
    }
    
    .pixel-grid.grid-off .pixel {
      border-color: transparent;
    }

    /* Modern Download Button */
    .download-button {
        --background: var(--accent-color);
        --text: #fff;
        padding: 12px 24px;
        font-family: 'Pretendard', sans-serif;
        font-weight: 600;
        border-radius: 8px;
        outline: none;
        border: none;
        text-decoration: none;
        font-size: 16px;
        background: var(--background);
        color: var(--text);
        box-shadow: 0 4px 12px -2px rgba(39, 94, 254, 0.45);
        transform: translateY(0);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        cursor: pointer;
    }
    .download-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px -2px rgba(39, 94, 254, 0.5);
    }

    /* Modal Styles */
    .modal-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
    }
    .modal-backdrop.visible {
        opacity: 1;
        pointer-events: auto;
    }
    .modal-content {
        background: var(--tool-bg);
        padding: 25px;
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        width: 90%;
        max-width: 320px;
        text-align: center;
        transition: background-color 0.3s, color 0.3s, border-color 0.3s;
    }
    .modal-content h3 { margin-bottom: 15px; }
    .modal-content input {
        width: 100%;
        padding: 10px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        margin-bottom: 15px;
        font-size: 16px;
        text-align: center;
    }
    .modal-buttons { display: flex; gap: 10px; }
    .modal-buttons button {
        flex: 1;
        padding: 10px;
        border-radius: 8px;
        border: none;
        font-size: 16px;
        cursor: pointer;
        transition: background-color 0.2s;
    }
    #modal-confirm { background-color: var(--accent-color); color: white; }
    #modal-confirm:hover { background-color: #1a4cdb; }
    #modal-cancel { background-color: var(--border-color); color: var(--text-color); }
    #modal-cancel:hover { background-color: #d0d5dc; }
    
    .clr-field button {
      border-radius: 50% !important;
      width: 34px !important;
      height: 34px !important;
      min-width: 34px !important;
    }
    
    /* Dark Mode */
    body.dark-mode {
      --text-color: #e0e0e0;
      --bg-color: #1a1b1e;
      --tool-bg: #2a2c30;
      --border-color: #404247;
      --grid-line-color: #404247;
      --shadow-color: rgba(0, 0, 0, 0.2);
    }
    body.dark-mode .tool-button:hover { background-color: #383a3f; }
    body.dark-mode .tool-button.active { color: #fff; }
    body.dark-mode #modal-cancel { background-color: #404247; }
    body.dark-mode #modal-cancel:hover { background-color: #55585e; }
    body.dark-mode .canvas-size input {
      background-color: var(--bg-color);
      color: #fff;
    }
    body.dark-mode #color-hex {
      background-color: var(--bg-color);
      color: #fff;
    }
    body.dark-mode .modal-content input {
  background-color: var(--bg-color);
  color: #fff;
    }
    
    @media (max-width: 768px) {
      :root { --pixel-size: var(--mobile-pixel-size); --default-pixel-size: var(--mobile-pixel-size); }
      .tool-group { border-right: none; padding: 2px; }
      .tool-button { width: 36px; height: 36px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>픽셀 아트 에디터</h1>
    
    <div class="tools">
      <div class="tool-group">
        <button id="pen-tool" class="tool-button active" title="펜 (P)"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.376 3.622a1 1 0 0 1 3.002 3.002L7.368 18.635a2 2 0 0 1-.855.506l-2.872.838a.5.5 0 0 1-.62-.62l.838-2.872a2 2 0 0 1 .506-.854z"/><path d="m15 5 3 3"/></svg></button>
        <button id="eraser-tool" class="tool-button" title="지우개 (E)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21"/><path d="M22 21H7"/><path d="m5 11 9 9"/></svg></button>
        <button id="fill-tool" class="tool-button" title="채우기 (F)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M19.2277 18.7323L20.9955 16.9645L22.7632 18.7323C23.7395 19.7086 23.7395 21.2915 22.7632 22.2678C21.7869 23.2441 20.204 23.2441 19.2277 22.2678C18.2514 21.2915 18.2514 19.7086 19.2277 18.7323ZM8.87861 1.07971L20.1923 12.3934C20.5828 12.7839 20.5828 13.4171 20.1923 13.8076L11.707 22.2929C11.3165 22.6834 10.6833 22.6834 10.2928 22.2929L1.80754 13.8076C1.41702 13.4171 1.41702 12.7839 1.80754 12.3934L9.58572 4.61525L7.4644 2.49393L8.87861 1.07971ZM10.9999 6.02946L3.92886 13.1005H18.071L10.9999 6.02946Z"></path></svg></button>
        
        <button id="eyedropper-tool" class="tool-button" title="스포이트 (I)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m2 22 1-1h3l9-9"/><path d="M3 21v-3l9-9"/><path d="m15 6 3.4-3.4a2.1 2.1 0 1 1 3 3L18 9l.4.4a2.1 2.1 0 1 1-3 3l-3.8-3.8a2.1 2.1 0 1 1 3-3l.4.4Z"/></svg></button>
      </div>
      <div class="tool-group">
        <div class="color-picker">
          <input type="text" id="color-input" data-coloris value="#000000">
          <input type="text" id="color-hex" value="0x000000">
        </div>
      </div>
      <div class="tool-group">
        <div class="canvas-size">
          <input type="number" id="width-input" min="3" max="64" value="16">
          <span class="size-separator">×</span>
          <input type="number" id="height-input" min="3" max="64" value="16">
          <button id="apply-size" class="tool-button" title="크기 적용"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg></button>
        </div>
      </div>
      <div class="tool-group">
        <button id="undo" class="tool-button" title="실행 취소 (Ctrl+Z)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 14 4 9 9 4"/><path d="M20 20v-7a4 4 0 0 0-4-4H4"/></svg></button>
        <button id="redo" class="tool-button" title="다시 실행 (Ctrl+Y)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 14 20 9 15 4"/><path d="M4 20v-7a4 4 0 0 1 4-4h12"/></svg></button>
        <button id="copy-all" class="tool-button" title="전체 복사"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg></button>
      </div>
      <div class="tool-group">
        <button id="clear-canvas" class="tool-button" title="모두 지우기"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg></button>
        <button id="grid-toggle" class="tool-button active" title="그리드 보기 (G)"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M3 9h18"/><path d="M3 15h18"/><path d="M9 3v18"/><path d="M15 3v18"/></svg></button>
      </div>
      <div class="tool-group">
        <label for="image-upload" class="tool-button" title="이미지 불러오기"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg><input type="file" id="image-upload" accept="image/*" style="display: none;"></label>
        <label for="project-upload" class="tool-button" title="프로젝트 열기"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z"/><path d="M2 10h20"/></svg><input type="file" id="project-upload" accept=".json,application/json" style="display: none;"></label>
        <button id="save-project" class="tool-button" title="프로젝트 저장"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg></button>
      </div>
    </div>

    <div class="canvas-container" id="canvas-container">
      <div class="pixel-grid" id="pixel-grid"></div>
    </div>
    
    <button id="download-image" class="download-button">Made by 여뉴</button>
  </div>
  
  <div class="modal-backdrop" id="export-modal">
    <div class="modal-content">
        <h3>이미지로 저장</h3>
        <p style="font-size: 14px; color: #888; margin-bottom: 15px;">이미지 크기 배율을 입력하세요. (권장 : 100)</p>
        <input type="number" id="export-scale" value="100" min="1" max="100">
        <div class="modal-buttons">
            <button id="modal-cancel">취소</button>
            <button id="modal-confirm">다운로드</button>
        </div>
    </div>
  </div>
          
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const state = {
        gridCols: 16,
        gridRows: 16,
        currentColor: '#000000',
        isDrawing: false,
        activeTool: 'pen',
        history: [],
        redoStack: [],
        currentState: [],
        isDarkMode: false
      };
      
      const elements = {
        pixelGrid: document.getElementById('pixel-grid'),
        canvasContainer: document.getElementById('canvas-container'),
        colorInput: document.getElementById('color-input'),
        colorHex: document.getElementById('color-hex'),
        widthInput: document.getElementById('width-input'),
        heightInput: document.getElementById('height-input'),
        applySizeButton: document.getElementById('apply-size'),
        penTool: document.getElementById('pen-tool'),
        eraserTool: document.getElementById('eraser-tool'),
        fillTool: document.getElementById('fill-tool'),
        eyedropperTool: document.getElementById('eyedropper-tool'),
        clearCanvas: document.getElementById('clear-canvas'),
        undoButton: document.getElementById('undo'),
        redoButton: document.getElementById('redo'),
        copyAllButton: document.getElementById('copy-all'),
        gridToggle: document.getElementById('grid-toggle'),
        saveProject: document.getElementById('save-project'),
        projectUpload: document.getElementById('project-upload'),
        imageUpload: document.getElementById('image-upload'),
        downloadButton: document.getElementById('download-image'),
        title: document.querySelector('h1'),
        exportModal: document.getElementById('export-modal'),
        exportScaleInput: document.getElementById('export-scale'),
        modalConfirm: document.getElementById('modal-confirm'),
        modalCancel: document.getElementById('modal-cancel')
      };
      
      function createGrid(cols, rows) {
        document.documentElement.style.setProperty('--grid-cols', cols);
        document.documentElement.style.setProperty('--grid-rows', rows);
        adjustPixelSize(cols);
        
        elements.pixelGrid.innerHTML = '';
        const fragment = document.createDocumentFragment();
        for (let i = 0; i < rows * cols; i++) {
          const pixel = document.createElement('div');
          pixel.classList.add('pixel');
          pixel.dataset.index = i;
          pixel.addEventListener('mousedown', handleMouseDown);
          pixel.addEventListener('mouseover', handleMouseOver);
          pixel.addEventListener('touchstart', handleTouchStart, { passive: false });
          pixel.addEventListener('touchmove', handleTouchMove, { passive: false });
          fragment.appendChild(pixel);
        }
        elements.pixelGrid.appendChild(fragment);
      }
      
      function adjustPixelSize(cols) {
          const containerWidth = elements.canvasContainer.clientWidth - 24; // account for padding
          const defaultSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--default-pixel-size'));
          const maxPixelSize = Math.floor(containerWidth / cols) - 1; // account for borders
          const newSize = Math.min(defaultSize, maxPixelSize);
          document.documentElement.style.setProperty('--pixel-size', `${Math.max(4, newSize)}px`);
      }

      function resetCanvas(cols, rows) {
          state.gridCols = cols;
          state.gridRows = rows;
          createGrid(cols, rows);
          state.currentState = Array(rows * cols).fill('#ffffff');
          updateCanvasFromState();
          state.history = [[...state.currentState]];
          state.redoStack = [];
          updateUndoRedoButtons();
      }
      
      function saveState() {
        if (state.history.length > 0 && JSON.stringify(state.history[state.history.length - 1]) === JSON.stringify(state.currentState)) return;
        state.history.push([...state.currentState]);
        if (state.history.length > 50) state.history.shift();
        state.redoStack = [];
        updateUndoRedoButtons();
      }
      
      function updateUndoRedoButtons() {
        elements.undoButton.disabled = state.history.length <= 1;
        elements.redoButton.disabled = state.redoStack.length === 0;
        elements.undoButton.style.opacity = elements.undoButton.disabled ? '0.5' : '1';
        elements.redoButton.style.opacity = elements.redoButton.disabled ? '0.5' : '1';
      }

      function rgbToHex(rgb) {
        if (!rgb || rgb === 'white') return '#ffffff';
        if (rgb.startsWith('#')) return rgb;
        const match = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
        if (!match) return '#000000';
        return "#" + ((1 << 24) + (parseInt(match[1]) << 16) + (parseInt(match[2]) << 8) + parseInt(match[3])).toString(16).slice(1);
      }

      function updateColor(color) {
          state.currentColor = color;
          elements.colorHex.value = '0x' + color.substring(1);
          elements.colorInput.value = color;
          elements.colorInput.style.backgroundColor = color;
      }
      
      function handleMouseDown(e) {
        if (e.button !== 0) return;
        const pixel = e.target;
        switch (state.activeTool) {
            case 'pen': case 'eraser':
                state.isDrawing = true;
                drawOnPixel(pixel);
                break;
            case 'fill':
                floodFill(pixel);
                saveState();
                break;
            case 'eyedropper':
                pickColor(pixel);
                break;
        }
      }

      function handleMouseOver(e) {
          if (state.isDrawing && (state.activeTool === 'pen' || state.activeTool === 'eraser')) {
              drawOnPixel(e.target);
          }
      }

      function drawOnPixel(pixel) {
          if (!pixel || !pixel.dataset.index) return;
          const index = parseInt(pixel.dataset.index);
          const newColor = state.activeTool === 'eraser' ? '#ffffff' : state.currentColor;
          if (state.currentState[index] !== newColor) {
              pixel.style.backgroundColor = newColor;
              state.currentState[index] = newColor;
          }
      }

      function pickColor(pixel) {
        updateColor(rgbToHex(pixel.style.backgroundColor));
        setActiveTool('pen');
      }
      
      function floodFill(startPixel) {
        const startIndex = parseInt(startPixel.dataset.index);
        const targetColor = state.currentState[startIndex];
        const replacementColor = state.currentColor;
        if (targetColor === replacementColor) return;
        const queue = [startIndex];
        const processed = new Set([startIndex]);
        state.currentState[startIndex] = replacementColor;
        while (queue.length > 0) {
            const currentIndex = queue.shift();
            const x = currentIndex % state.gridCols;
            const y = Math.floor(currentIndex / state.gridCols);
            [[x+1,y], [x-1,y], [x,y+1], [x,y-1]].forEach(([nx, ny]) => {
                if (nx >= 0 && nx < state.gridCols && ny >= 0 && ny < state.gridRows) {
                    const neighborIndex = ny * state.gridCols + nx;
                    if (!processed.has(neighborIndex) && state.currentState[neighborIndex] === targetColor) {
                        processed.add(neighborIndex);
                        state.currentState[neighborIndex] = replacementColor;
                        queue.push(neighborIndex);
                    }
                }
            });
        }
        updateCanvasFromState();
      }

      function handleTouch(e, isMove) {
        e.preventDefault();
        const touch = e.touches[0];
        const pixel = document.elementFromPoint(touch.clientX, touch.clientY);
        if (!pixel || !pixel.classList.contains('pixel')) return;
        switch (state.activeTool) {
            case 'pen': case 'eraser':
                if (!isMove) state.isDrawing = true;
                if (state.isDrawing) drawOnPixel(pixel);
                break;
            case 'fill': if (!isMove) { floodFill(pixel); saveState(); } break;
            case 'eyedropper': if (!isMove) pickColor(pixel); break;
        }
      }
      const handleTouchStart = (e) => handleTouch(e, false);
      const handleTouchMove = (e) => handleTouch(e, true);
      
      function changeCanvasSize() {
        let newWidth = parseInt(elements.widthInput.value, 10) || 16;
        let newHeight = parseInt(elements.heightInput.value, 10) || 16;
        newWidth = Math.max(3, Math.min(64, newWidth));
        newHeight = Math.max(3, Math.min(64, newHeight));
        elements.widthInput.value = newWidth;
        elements.heightInput.value = newHeight;
        resetCanvas(newWidth, newHeight);
      }
      
      function undo() {
        if (state.history.length <= 1) return;
        state.redoStack.push(state.history.pop());
        state.currentState = [...state.history[state.history.length - 1]];
        updateCanvasFromState();
        updateUndoRedoButtons();
      }
      
      function redo() {
        if (state.redoStack.length === 0) return;
        const redoState = state.redoStack.pop();
        state.history.push(redoState);
        state.currentState = [...redoState];
        updateCanvasFromState();
        updateUndoRedoButtons();
      }
      
      function updateCanvasFromState() {
        const pixels = elements.pixelGrid.children;
        for(let i=0; i < pixels.length; i++) {
            pixels[i].style.backgroundColor = state.currentState[i];
        }
      }
      
      function copyAll() {
        const result = state.currentState.map((hexColor, i) => {
            let line = `<span style="background-color:${hexColor}; color:${hexColor}">█</span>`;
            if ((i + 1) % state.gridCols === 0 && i < state.currentState.length - 1) {
                line += '\n';
            }
            return line;
        }).join('');
        navigator.clipboard.writeText(result);
      }
      
      function handleImageUpload(e) {
        const file = e.target.files[0];
        if (!file || !file.type.match('image.*')) return;
        const reader = new FileReader();
        reader.onload = (event) => {
          const img = new Image();
          img.onload = () => {
            const tempCanvas = document.createElement('canvas');
            const ctx = tempCanvas.getContext('2d');
            tempCanvas.width = state.gridCols; tempCanvas.height = state.gridRows;
            ctx.drawImage(img, 0, 0, state.gridCols, state.gridRows);
            const imageData = ctx.getImageData(0, 0, state.gridCols, state.gridRows).data;
            state.currentState = Array.from({ length: state.gridCols * state.gridRows }, (_, i) => 
                imageData[i*4+3] > 128 ? rgbToHex(`rgb(${imageData[i*4]}, ${imageData[i*4+1]}, ${imageData[i*4+2]})`) : '#ffffff'
            );
            updateCanvasFromState();
            saveState();
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
        e.target.value = '';
      }

      function toggleGrid() {
        elements.pixelGrid.classList.toggle('grid-off');
        elements.gridToggle.classList.toggle('active');
      }

      function saveProject() {
          const projectData = { width: state.gridCols, height: state.gridRows, pixels: state.currentState };
          const blob = new Blob([JSON.stringify(projectData)], { type: 'application/json' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = `pixel-art-${Date.now()}.json`;
          a.click();
          URL.revokeObjectURL(a.href);
      }

      function loadProject(e) {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (event) => {
              try {
                  const data = JSON.parse(event.target.result);
                  if (data.width && data.height && Array.isArray(data.pixels)) {
                      elements.widthInput.value = data.width;
                      elements.heightInput.value = data.height;
                      resetCanvas(data.width, data.height);
                      state.currentState = data.pixels;
                      updateCanvasFromState();
                      state.history = [[...state.currentState]]; // Reset history with loaded state
                  }
              } catch (error) { console.error("Failed to load project:", error); }
          };
          reader.readAsText(file);
          e.target.value = '';
      }
      
      function showExportModal() { elements.exportModal.classList.add('visible'); }
      function hideExportModal() { elements.exportModal.classList.remove('visible'); }

      function performDownload(scale = 10) {
        const canvas = document.createElement('canvas');
        canvas.width = state.gridCols * scale;
        canvas.height = state.gridRows * scale;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        for (let y = 0; y < state.gridRows; y++) {
            for (let x = 0; x < state.gridCols; x++) {
                ctx.fillStyle = state.currentState[y * state.gridCols + x];
                ctx.fillRect(x * scale, y * scale, scale, scale);
            }
        }
        const link = document.createElement('a');
        link.download = `pixelart_${state.gridCols}x${state.gridRows}_@${scale}x.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
        hideExportModal();
      }

      function toggleDarkMode() {
        state.isDarkMode = !state.isDarkMode;
        document.body.classList.toggle('dark-mode', state.isDarkMode);
        localStorage.setItem('pixelArtEditorDarkMode', state.isDarkMode);
      }

      function initDarkMode() {
        if (localStorage.getItem('pixelArtEditorDarkMode') === 'true') {
          state.isDarkMode = true;
          document.body.classList.add('dark-mode');
        }
      }

      function setActiveTool(tool) {
          state.activeTool = tool;
          [elements.penTool, elements.eraserTool, elements.fillTool, elements.eyedropperTool]
            .forEach(button => button.classList.remove('active'));
          document.getElementById(`${tool}-tool`)?.classList.add('active');
      }

      function setupEventListeners() {
        const endDrawing = () => { if (state.isDrawing) { saveState(); state.isDrawing = false; }};
        document.addEventListener('mouseup', endDrawing);
        document.addEventListener('touchend', endDrawing);
        
        elements.colorHex.addEventListener('change', (e) => {
            let hex = e.target.value;
            if (!hex.startsWith('#')) hex = '#' + hex.replace('0x', '');
            updateColor(hex);
        });
        elements.applySizeButton.addEventListener('click', changeCanvasSize);
        elements.clearCanvas.addEventListener('click', () => resetCanvas(state.gridCols, state.gridRows));
        elements.penTool.addEventListener('click', () => setActiveTool('pen'));
        elements.eraserTool.addEventListener('click', () => setActiveTool('eraser'));
        elements.fillTool.addEventListener('click', () => setActiveTool('fill'));
        elements.eyedropperTool.addEventListener('click', () => setActiveTool('eyedropper'));
        elements.undoButton.addEventListener('click', undo);
        elements.redoButton.addEventListener('click', redo);
        elements.copyAllButton.addEventListener('click', copyAll);
        elements.imageUpload.addEventListener('change', handleImageUpload);
        elements.projectUpload.addEventListener('change', loadProject);
        elements.saveProject.addEventListener('click', saveProject);
        elements.gridToggle.addEventListener('click', toggleGrid);
        elements.title.addEventListener('dblclick', toggleDarkMode);
        elements.downloadButton.addEventListener('click', showExportModal);
        elements.modalConfirm.addEventListener('click', () => performDownload(parseInt(elements.exportScaleInput.value) || 10));
        elements.modalCancel.addEventListener('click', hideExportModal);
        window.addEventListener('resize', () => adjustPixelSize(state.gridCols));
        document.addEventListener('keydown', (e) => {
            if (document.activeElement.tagName === 'INPUT' || elements.exportModal.classList.contains('visible')) {
                if(e.key === 'Escape') hideExportModal();
                if(e.key === 'Enter') elements.modalConfirm.click();
                return;
            }
            if (e.ctrlKey || e.metaKey) {
                if (e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); }
                if (e.key.toLowerCase() === 'y') { e.preventDefault(); redo(); }
            } else {
                const keyMap = { p: 'pen', e: 'eraser', f: 'fill', i: 'eyedropper', g: toggleGrid };
                const action = keyMap[e.key.toLowerCase()];
                if (typeof action === 'function') action();
                else if (action) setActiveTool(action);
            }
        });
      }
      
      Coloris({ themeMode: 'auto' });
      document.addEventListener('coloris:pick', event => updateColor(event.detail.color));
      
      initDarkMode();
      resetCanvas(state.gridCols, state.gridRows);
      updateColor('#000000');
      setupEventListeners();
    });
  </script>
</body>
  </html>
